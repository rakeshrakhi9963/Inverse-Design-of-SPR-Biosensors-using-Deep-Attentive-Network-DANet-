# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mFq1Dbzs7BFlmbJum-8hc-eqRj0V34Gu
"""

import numpy as np
import matplotlib.pyplot as plt
import csv

# Constants
c = 2.998e8  # Speed of light in m/s
baseline_n_sens = 1.2995
wavelengths_nm = np.linspace(400, 1000, 300)  # Wavelength range in nm

# Fiber core index function
def n_core_model(lmda_um):
    l = 0.035
    C0, C1, C2, C3, C4, C5 = 1.4508554, -0.0031268, -0.0000381, 0.0030270, -0.0000779, 0.0000018
    return (C0 + C1 * lmda_um ** 2 + C2 * lmda_um ** 4 +
            (C3 / (lmda_um ** 2 - l)) +
            (C4 / (lmda_um ** 2 - l) ** 2) +
            (C5 / (lmda_um ** 2 - l) ** 3))

# Function to simulate transmitted power (simplified dip shape)
def simulate_spectrum(num_a, thicknesses, L_mm, n_sens, selected_metal):
    # Determine the active thickness based on selected metal
    d1_nm = thicknesses.get(selected_metal, 0)

    # Calculate resonance center based on selected metal
    resonance_center = 600 + (n_sens - 1.33) * 10000 - (num_a - 0.3) * 300 + (d1_nm - 45) * 2
    fwhm = 30 + (0.5 - num_a) * 20 + abs(d1_nm - 45) * 0.5
    dip_depth = 0.7 + (n_sens - 1.33) * 2

    transmission = 1 - dip_depth * np.exp(-4 * np.log(2) * ((wavelengths_nm - resonance_center) ** 2) / fwhm ** 2)
    return wavelengths_nm, transmission, resonance_center, fwhm

# Find resonance wavelength and FWHM
def get_metrics(wavelengths, powers):
    min_idx = np.argmin(powers)
    res_wavelength = wavelengths[min_idx]
    min_power = powers[min_idx]

    # FWHM: Find points where power crosses (min + max)/2
    target = (1 + min_power) / 2
    crossings = np.where(np.diff(np.sign(powers - target)))[0]
    if len(crossings) >= 2:
        fwhm = wavelengths[crossings[-1]] - wavelengths[crossings[0]]
    else:
        fwhm = np.nan
    return res_wavelength, fwhm

# User selection for metal
selected_metal = input("Enter the metal to combine with graphene (silver, gold, copper, aluminum): ").strip().lower()

# Define thickness ranges for each metal (can be adjusted based on literature)
thickness_ranges = {
    'silver': range(35, 56, 1),
    'gold': range(35, 56, 1),
    'copper': range(35, 56, 1),
    'aluminum': range(35, 56, 1)
}

# Define graphene layer range (1 to 3 layers)
graphene_layers_range = [1, 2, 3]  # Each layer ~0.34 nm

# Dataset output
output_file = f'spr_dataset_graphene_{selected_metal}.csv'
with open(output_file, 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerow(['NumA', 'Silver_thickness_nm', 'Gold_thickness_nm', 'Copper_thickness_nm',
                     'Aluminum_thickness_nm', 'Graphene_layers', 'Sensing_length_mm', 'n_sens',
                     'Resonance_lambda_nm', 'FWHM_nm', 'Sensitivity_nm_per_RIU'])

    for numa in np.arange(0.1, 0.6, 0.1):
        for graphene_layers in graphene_layers_range:
            for thickness in thickness_ranges[selected_metal]:
                for L in range(5, 31, 1):
                    for n_sens in np.arange(1.33, 1.401, 0.005):
                        # Initialize all thicknesses to zero
                        thicknesses = {
                            'silver': 0,
                            'gold': 0,
                            'copper': 0,
                            'aluminum': 0,
                            'graphene': 0
                        }
                        # Set the selected metal's thickness
                        thicknesses[selected_metal] = thickness
                        # Set graphene thickness (number of layers)
                        thicknesses['graphene'] = graphene_layers

                        wl, pt, _, _ = simulate_spectrum(numa, thicknesses, L, n_sens, selected_metal)
                        res_lambda, fwhm = get_metrics(wl, pt)

                        # Simulate baseline for sensitivity
                        wl_baseline, pt_baseline, _, _ = simulate_spectrum(numa, thicknesses, L, baseline_n_sens, selected_metal)
                        res_baseline, _ = get_metrics(wl_baseline, pt_baseline)

                        sensitivity = (res_lambda - res_baseline) / (n_sens - baseline_n_sens) if n_sens != baseline_n_sens else 0

                        writer.writerow([
                            numa,
                            thicknesses['silver'],
                            thicknesses['gold'],
                            thicknesses['copper'],
                            thicknesses['aluminum'],
                            thicknesses['graphene'],
                            L,
                            round(n_sens, 4),
                            round(res_lambda, 2),
                            round(fwhm, 2),
                            round(sensitivity, 2)
                        ])

print(f"âœ… Dataset generation completed for graphene and {selected_metal}. Saved to '{output_file}'")